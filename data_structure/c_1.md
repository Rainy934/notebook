### 关于递归
#### 什么是递归
> 递归是一种用自己定义自己的一种思想，比如斐波那契数列，举例来说： 存在f(0) = 1, f(x) = f(x-1) + f(x - 2);
#### 需求
> 需要得出f(x) x >= 0, 在这非负整数集合内的序列
解决方案：
1. 迭代循环 - 特点：比较直观的得出答案，效率一般。
2. 递归求解 - 特点：对于理解算法思想有帮助，计算机模拟执行效率较低

#### 结论
递归是一种思想，使用它便于理解算法思想，也能使得程序代码简洁。但是算法使用必须要有其实用性，在这里递归的方式，对于求解斐波那契数据列效率是非常低下的。
递归应用基本原则：
1. 基准情形。任何一个可递归解决的问题都必须要有一些基准值的确定，不需要依靠递归。
2. 不断推进。
3. 设计法则。 每一步递归推进是可实现可运行的
4. 合成效益法则。 每一小步算法覆盖率最小。

#### 子序列和问题
1. 联机算法

### O(logN)的一般性判断法则
1. 能通过O（1）把问题分治为1/2的算法

#### 排序-对分查找
1. 先排序再查找

#### 欧几德里算法（计算最大公因数）
1. a, b 均可被z整除 => (ax + by) % z = 0 (x, y j均为整数)，此处的z可为所有公因数，包括最大公因数
2. a % b = c => bx + c = a => a - bx = c 可得知大数除小数的余数 同样也可以被z整除，此处的z可为所有公因数，包括最大公因数
3. 那么大数和小数的公因数z，同样也是余数c和小数的公因数
4. 如何得出这个z呢，而且怎么知道它是最大的呢？
5. 辗转相除法，每次均以小数作为假想最大公因数（很好论证，如果能整除，那么大数和小数的最大公因数就是小数）
6. 不能整除，说明最大公因数小于小数，而这个时候来看余数c，首先余数能被最那个最大公因数整除，说明余数c 大于 最大公因数，其次 余数 c 小于 小数，此处可将大数和小数的公因数问题转换为小数和余数的最大公因数问题
7. 再次进行尝试，小数作为假想最大公因数...
8. 结果最差也就是最后小数一直越来越小，但是不可能为负数，当为0时也是答案出来了，有可能回得出最大公因数为1（这是最差的结果）

### 取幂算法
1. f(x) = pow(a, x) 实现函数pow